空间优化: 

对于网格的dp，如果```f[i][j]```只依赖本行的```f[i][x]```和上一行的```f[i-1][y]```, 那么可以采用滚动数组压缩空间. 空间复杂度为```O(n)```而不是```O(m*n)```

1. Minimum Path Sum: 如果要打印path, 关键: 记录每一次是从left还是up的方向来的; 最后的path是从```A[m-1][n-1]```倒着得到的; 然后再reverse打印出来;
2. Longest Increasing Subsequence; ```dp[i][j]```记录到```grid[i][j]```的位置的LIS长度;
3. Bomb Enemy: 四个方向; e.g. 从上面来的方向: ```if(i>0) up[i][j] = up[i-1][j]+1```;
---

异或: 不进位的加法: 1^1 = 0;

4. Counting Bits: 

  1. brute-force:这个数不断mod2, floor(i/2); 直到最后为0: ``O(NlogN)```;
  2. dp; 每个二进制数看最后一位是0/1, 再看去掉最后一位之后剩下的二进制有多少个1;
  3. ```>>```:右移相当于除2往下找floor();
  4. ```<<```:左移相当于乘2;
  5. 另外, ```i%2```是很慢的, ```i & 1```有相同的作用, 但是位操作比mod快很多;
